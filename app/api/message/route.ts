// app/api/message/route.ts
import { NextRequest } from "next/server";

export async function POST(req: NextRequest) {
  const { mode, userInput } = await req.json();

  let reply = "";

  if (mode === "plan") {
    // ✅ 완성본 사업계획서
    reply =
`# AI 사업계획서

## 1. 사업 개요
- **사업 명**: 여행 일정 자동 최적화 서비스
- **서비스 소개**: 대화형으로 요구사항을 받아 AI가 일정/루트를 자동 생성하고, 혼잡도·날씨를 반영해 재배치
- **기획 배경**: 정보 과잉과 최신성 부족으로 여행 계획에 과도한 시간 소요
- **비전·가치**: "최소 입력, 최대 만족" — 개인화·실시간성으로 계획 스트레스 제거

## 2. 시장 분석
- **시장 규모/성장률(예시)**  
  | 연도 | 시장규모(조원) | 성장률 |
  | --- | ---: | ---: |
  | 2024 | 12.0 |  —  |
  | 2025 | 14.2 | +18% |
  | 2026 | 16.4 | +15% |
- **경쟁사 비교(예시)**  
  | 항목 | 우리 | 구글/맵 | OTA 앱 |
  | --- | --- | --- | --- |
  | 개인화 | **강** | 중 | 중 |
  | 실시간 재배치 | **강** | 약 | 약 |
  | 동선 최적화 | **강** | 중 | 약 |
  | 수익모델 | 구독+제휴 | 광고 | 제휴 |
- _(그래프 자리)_ **[그래프: 시장규모/성장률, 경쟁사 포지션 맵]**

## 3. 제품/서비스
- **핵심 기능**: 일정 자동생성, 혼잡도·날씨 반영 재배치, 리뷰 요약, 동선 최적화, 예산 제약 최적화
- **차별화 포인트**: 실시간성, 고도 개인화, 대화형 UX, 로컬 파트너 연동

## 4. 비즈니스 모델
- **수익 구조**: 구독(Pro), 제휴 수수료(티켓/투어/교통), 스폰서 카드
- **타깃 고객층**: 20–40대 셀프 플래너 / 로컬 파트너(티켓·투어)
- _(다이어그램 자리)_ **[다이어그램: 고객→제품→수익 플로우]**

## 5. 운영 계획
- **출시 전략**: 알파테스트 → 커뮤니티 런칭 → 앱스토어 ASO
- **마케팅**: 인플루언서/커뮤니티·SEO·제휴 랜딩
- **제휴/파트너**: 지역 투어/티켓, 교통/패스, 맛집/체험

## 6. 재무 계획
- **예상 추이(예시)**  
  | 분기 | 매출(백만) | 비용(백만) | 이익(백만) |
  | --- | ---: | ---: | ---: |
  | Q1  | 0    | 50   | -50 |
  | Q2  | 30   | 70   | -40 |
  | Q3  | 120  | 100  | 20  |
  | Q4  | 240  | 150  | 90  |
- **손익분기점(BEP)**: Q3 말 예상  
- _(그래프 자리)_ **[그래프: 매출/비용/이익 추이, BEP 라인]**

> ※ 데모용 표/값은 예시입니다. 실제 연결 시 추정치/데이터로 교체해주세요.`;
  } else if (mode === "idea") {
    // ✅ 요청하신 아이디어 분기
    reply =
`다음은 여행 관련 아이디어입니다:
- 성수기/비성수기 최적 루트 추천(예산/날씨 반영)
- 리뷰 요약 기반 '현지 맛집' 카드
- 실시간 혼잡도·대기시간 반영 일정 재배치
- 동선 최적화(도보/대중교통/렌터카 선택)
- 패키지 vs 개별일정 비교견적`;
  } else {
    reply = `좋아요. "${userInput?.slice(0, 40) || "아이디어"}" 방향으로 핵심 기능 3가지를 제안해볼게요:
1) 실시간 혼잡도 반영 일정 재배치
2) 리뷰 요약 기반 장소 선택 보조
3) 예산/시간 제약 최적화 옵션`;
  }

  // SSE 스트리밍
  const enc = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      for (const line of reply.split("\n")) {
        controller.enqueue(enc.encode(`data: ${line}\n\n`));
        await new Promise(r => setTimeout(r, 12));
      }
      controller.enqueue(enc.encode(`data: [DONE]\n\n`));
      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream; charset=utf-8",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "X-Accel-Buffering": "no",
    },
  });
}
